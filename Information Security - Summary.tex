 
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{ragged2e}

\title{\textbf{Information Security: Principles and Practice\\ Mark Stamp}\\ Summary}
\author{\textbf{\textit{Sebastiano Mirabella}}}

\pagenumbering{roman}
\begin{document}
\date{}
\maketitle
\tableofcontents
\newpage
\pagenumbering{arabic}

\section{Information Security : Aims}
\subsection{CIA}
\begin{itemize}
    \item \textbf{Confidentiality} : Preventing unauthorized \textit{reading} of information.\\
            Unauthorized access to:
            \begin{itemize}
                \item medical records
                \item financial information
                \item student progress data
            \end{itemize}
    \item \textbf{Integrity} : Preventing unauthorized \textit{writing/modification} of information.\\
            Comprising information stored in computers:
            \begin{itemize}
                \item legal records
                \item tax information
                \item financial data
            \end{itemize}
    \item \textbf{Availability} : The information/service must be \textit{available} when needed.\\
    Service disruption:
    \begin{itemize}
        \item resource blocking/stealing
        \item slowed down computer or network
        \item downtime, costly repairs
    \end{itemize}
\end{itemize}
\subsection{Defense in Depth}
We consider a network configuration with multiple layers of protection to define defense in depth. An example would be a network which includes a packet filter firewall, an application proxy and personal firewalls as well as a demilitarized zone, or DMZ.\\
The packet filter is used to prevent common attacks on the systems in the DMZ. The systems in the DMZ must be carefully maintained by the Administrator since they are the ones who are mostly exposed to attacks.

\newpage
\section{Classic Crypto}

\subsection{How to speak crypto}
\begin{itemize}
    \item \textbf{Public key:} Key that is kept public and needed for encryption.
    \item \textbf{Private key:} Key that is kept private and used for decryption.
    \item \textbf{Symmetric key:} Key that is used for symmetric key crypto.
    \item \textbf{Kerckhoff's principle:} While the key must be secret the encryption algorithm must be public.
    \item \textbf{Definition of Secure:} A cryptosystem is \textit{secure} if the best-known attack requires as much work as an exhaustive key search (no shortcut attack is known).
\end{itemize}

\subsection{Simple Substitution Cipher}
A massage is encrypted by using the letter of the alphabet n places ahead of the current letter. The way this can be broken is through one of the most elementary crypto attack which is known as the \textit{exhaustive key} search. A simple substitution cipher can employ any permutations of the English alphabet as a key, meaning that there are $26! = 2^{88}$ possible keys.

\subsubsection{Cryptoanalysys of a Simple Substitution}
To break a simple substitution cipher an attacker may use an English frequency table (given that the used alphabet is English) to compare it with the frequency table of the cyphertext, and by a simple substitution it would be possible to guess the plaintext. 

\subsection{Double Transposition Cipher}
To encrypt with a double transposition cipher, we first write the plaintext into an array of a given size and then permute the rows and columns according to specified permutations. The key will then be the size of the matrix and the row and column permutations

\subsection{One-time-Pad / Vernam Cipher}
The one-time-pad key consists of a string of randomly selected bits that is the same length as the message. The random key is then XORed with the plaintext to yield the ciphertext. The decryption is the same but you would XOR the ciphertext with the key to obtain the ciphertext.
\begin{center}
    \justify
    To \textbf{Encrypt}: $E_k(p,k) = c = (p + k) \% 26$\\
    To \textbf{Decrypt}: $D_k(c,k) = p = (26 + c - k) \% 26$
\end{center}

\newpage
\section{Symmetric Key Crypto}

\subsection{Stream Ciphers}
A stream cipher takes a key K of $n$ bits in length and stretches it into a long \textit{keystream}. The keystream is then XORed with the plaintext P to produce the ciphertext C. To recover P you would XOR the keystream with C.

\subsubsection{A5/1}
The A5/1 uses three \textit{registers} X,Y,Z where each of them holds 19, 22 and 23 bits correspondingly, for a total of 64 bits.\\
Each register has a different series of operations:

\begin{itemize}
    \item Register X:
    \begin{itemize}
        \item $t = x_{13} \oplus x_{16} \oplus x_{17} \oplus x_{18}$
        \item $x_i = x_{i-1}$ for $i = 18,17,16,...,1$
        \item $x_0 = t$
    \end{itemize}
    \item Register Y:
    \begin{itemize}
        \item $t = y_{20} \oplus y_{21}$
        \item $y_i = y_{i-1}$ for $i = 21,20,19,...,1$
        \item $y_0 = t$
    \end{itemize}
    \item Register Z:
    \begin{itemize}
        \item $t = z_{7} \oplus z_{20} \oplus z_{21} \oplus z_{22}$
        \item $z_i = z_{i-1}$ for $i = 22,21,20,...,1$
        \item $z_0 = t$
    \end{itemize}
\end{itemize}

For each keystream bit generated the following takes place:
\begin{itemize}
    \item Compute $m = maj(x_8,y_{10},z_{10})$ where if the majority is 0 then a 0 is returned else a 1.
    \item Each register will then step as follows:
    \begin{itemize}
        \item if $x_8 = m$, then X steps
        \item if $y_{10} = m$, then Y steps
        \item if $z_{10} = m$, then Z steps
    \end{itemize}
    \item A single keystream bit s is generated as: $s = x_{18} \oplus y_{21} \oplus z_{22}$
\end{itemize}

After we generate the keystream bit $s = x \oplus y \oplus z$, it can then be XORed with the plaintext P to get the ciphertext C.

\subsubsection{RC4}
RC4 produce a keystream byte at each step. It is essentially a lookup table containing the permutation of all possible 256 byte values.\\\\
The first step of the algorithm is to initialize the lookup table, this is done by using a key[$i$] for $i = \{0,1,...,N-1\}$ where each key[i] is a byte. We denote the lookup table S[$i$] for $i = \{0,1,...,N-1\}$, where each S[$i$] is also a byte. The key can be of any length from 1 to 256 bytes (key only used to initialize permutation S).\\\\
The 256-byte array $K$ is filled by repeating the Key until the array is full. The \textbf{keystreamByte}, is a single byte which is XORed with the plaintext to encrypt or XORed with the ciphertext to decrypt.\\\\
There are certain attacks which are infeasible if we discard the first 256 keystream bytes that are generated. This is achieved by adding 256 steps to the initialization phase, where each step generates and discards a keystream byte

\subsection{Block Ciphers}
A block cipher splits the plaintext into fixed-sized blocks and generates fixed-sized blocks of ciphertext. The ciphertext is obtained by iterating a function F (known as round function) over some number of rounds.\\
The design goal of block ciphers are \textbf{security} and \textbf{efficiency}.

\subsubsection{Feistel Cipher}
\begin{center}
    \textit{Invented by Host Feistel}
\end{center}
In a Feistel cipher the plaintext P is split into left and right halves denoted as:
\begin{center}
    P = $(L_0,R_0)$
\end{center}{}
For each round i = \{1,2,...,n\} the left and right halves are computed as follows
\begin{center}
\begin{tabular}{l}
    $L_i = R_{i-1}$\\
    $R_i = L_{i-1} \oplus F(R_{i-1}, K_i) $
\end{tabular}{}
\end{center}{}
Where $K_i$ is the subkey generated for round i. The subkey is derived from the key K according to a specified \textit{key schedule} algorithm.\\
To decrypt the opposite take place and it works as such:
\begin{center}
\begin{tabular}{l}
    $R_{i-1} = L_{i}$\\
    $L_{i-1} = R_i \oplus F(R_{i-1}, K_i) $
\end{tabular}{}
\end{center}{}
The ciphertext C is the output of the final round, namely,
\begin{center}
    C = $(L_n, R_n)$
\end{center}
All questions about security in a Feistel cipher boil down to questions about the round function and key schedule.

\subsubsection{DES}
The \textit{Data Encryption Standard} is a Feistel Cipher and has the following characteristics:
\begin{itemize}
    \item 16 rounds
    \item 64-bit block length
    \item 56-bit key
    \item 48-bit subkeys
    \item Exhaustive key search: $2^{55}$
\end{itemize}
In DES each S-box maps 6 bits to 4 bits and there are eight distinct S-boxes. All of them together map a total of 48 bits to 32 bits, the same S-boxes are used at each round of DES and each of them is implemented as a lookup table.\\
The DES function can be seen as follows:
\begin{center}
    F($R_{i-1}$, $K_i$) = P-box(S-boxes(Expand($R_{i-1}$) $\oplus$ $K_{i}$))
\end{center}
The expansion permutation expands its input from 32 to 48 bits, and the subkey is XORed with the result. The S-boxes then compress these 48 bits down to 32 bits before the result is passed through the P-box. The P-box output is XORed with the old left half to obtain the new right half.

\begin{figure}[H]
    \centering
    \caption{One round of DES}
    \includegraphics[width=8cm]{DESround.png}
\end{figure}
Each of the eight DES S-boxes maps 6 bits to 4 bits, and, consequently, each can be viewed as an array of 4 rows and 16 columns, with one nibble (4-bit value) stored in each of the 64 positions.

\subsubsection{Triple DES or 3DES}
The triple DES is a similar encryption algorithm as the normal DES however it is defined as such:
\begin{center}
    C = E(D(E(P,K1),K2),K1).
\end{center}{}
From the above it can be seen that 3DES uses two keys and encrypt-decrypt-encrypt method, or EDE. The reason for using two keys instead of three is that 112 bits are enough and a third key would not add much security to the algorithm.\\
The reason of why we use EDE and not EEE is backwards compatibility, if it is used with K1 = K2 = K then it would collapse to a single DES, and then we would have
\begin{center}
    C = E(D(E(P, K), K),K) = E(P, K)
\end{center}{}

\subsubsection{Attack?!?}
Attacks such as meet-in-the-middle attack of the type used against double DES is impractical since the table pre-computation is infeasible or the per attack work is infeasible.

\subsection{Block Cipher Modes}
To encrypt multiple blocks in block ciphers we can use different block cipher modes such as the \textit{electronic codebook mode} or ECB, \textit{cipher block chaining mode} or CBC and the \textit{counter mode} or CTR.

\subsubsection{Electronic codebook mode / ECB}
For a fixed key K we use the ECB mode to encrypt multiple blocks this is shown by the formula:
\begin{center}
    $C_i$ = E($P_i$, K) for i = 0,1,2,....
\end{center}{}
And then we can decrypt according to
\begin{center}
    $P_i$ = D($C_i$, K) for i = 0,1,2,....
\end{center}{}
Suppose ECB mode is used, and an attacker observes that $C_i$ = $C_j$. Then the attacker knows that $P_i$ = $P_j$. Therefore the attacker might know a part of the plaintext, and any match with a known block reveals another block.

\subsubsection{Cipher block chaining mode / CBC}
In CBC the ciphertext from a block is used to obscure the plaintext of the next block before it is encrypted, the encryption formula for the CBC mode is:
\begin{center}
    $C_i$ = E($P_i \oplus C_{i-1}$,K) for $i = 0,1,2,...,$
\end{center}{}
which is then decrypted by
\begin{center}
    $P_i$ = D($C_i$, K) $\oplus$ $C_{i-1}$ for $i = 0,1,2,...,$
\end{center}{}
For the first block since we do not have any block for $C_{i-1}$, we use an IV or \textit{Initialization Vector} to take the place of $C_{i-1}$. Due to the fact that we are using an IV, the first block will be decrypted / encrypted differently.
\begin{center}
    $C_0$ = E($P_0 \oplus $ IV,K)
\end{center}{}
\begin{center}
    $P_0$ = D($C_0,K) \oplus $ IV
\end{center}{}
Since there is no need that the IV is secret, it is usually randomly generated at encryption time and sent as the first "ciphertext" block. When decrypting the IV must be handled appropriately.\\
However there is a problem, that if there is a single-bit error it can cause two entire blocks to be garbled, and is a serious concern in high error-rate environments such as wireless communication.

\subsubsection{Counter mode / CTR}
The \textit{counter mode} or CTR employs an IV similar to CBC however the encryption/decryption works differently.
\begin{center}
    $C_i = P_i \oplus E(IV + i,K)$
\end{center}{}
\begin{center}
    $P_i = C_i \oplus E(IV + i,K)$
\end{center}{}
This code block mode is often used when random access is required. While random access is also fairly straightforward with CBC mode. However there are some cases in which CBC would not be desirable for random access. 

\subsection{Integrity}
Whereas \textit{confidentiality} deals with preventing unauthorized reading, \textit{integrity} is concerned with detecting unauthorized writing.\\
To ensure integrity a \textit{Message Authentication Code} or MAC uses a block cipher to ensure data integrity. It simply encrypt the data in CBC mode, discarding all ciphertext block except the final one. The final block is also known as the CBC residue will serve as the MAC.\\
The formula for the MAC assuming N blocks of data is given by
\begin{center}
    $C_{N-1} = E(P_{N-1} \oplus C_{N-2},K)$ = MAC
\end{center}
The way integrity is maintained is by using a key K that A and B share, A will compute the MAC and send the plaintext, IV and MAC to B. When B receives the message using the key K and the received IV and plaintext he will compute the MAC and if his MAC matches the received MAC then it means that data integrity was not violated.\\
This check works because if any of the blocks is modified then the subsequent blocks will be modified as well and the MAC will not be the same.

\newpage
\section{Public key Crypto}
In public key cryptography one key is used to encrypt and a different key is used to decrypt, the encryption key can be made public.

\subsection{Knapsack}
The knapsack problem can be stated as follows. Given a set of n weights labeled as $W_0,W_1,...,W_{n-1}$ and a desired sum S, find $a_0,a_1,...,a_{n-1}$ where each $a_i \in \{0,1\}$, so that
\begin{center}
    S = $a_0W_0 + a_1W_1 + ... + a_{n-1}W_{n-1}$
\end{center}{}

\subsubsection{Example}
Suppose that we have the weights: $85,13,9,7,47,27,99,86$ and the desired sum $S = 172$. Then a solution to the problem is given by
\begin{center}
    a = (a0,a1,a2,a3,a4,a5,a6,a7) = (11001100)
\end{center}{}
since 85 + 13 + 47 + 27 = 172

\subsection{Superincreasing Knapsack}
In a superincreasing knapsack, the weights are arranged from least to greatest, each weight is greater than sum of all previous weights.\\
The process to construct a superincreasing knapsack cryptosystem, begins with a superincreasing knapsack, from which we generate a public and private key pair. The steps are as follows:

\begin{enumerate}
    \item Generate a superincreasing knapsack.
    \item Convert the superincreasing knapsack into a general knapsack.
    \item The public key is the general knapsack.
    \item The private key is the superincreasing knapsack together with the conversion factors.
\end{enumerate}

To convert the superincreasing knapsack into a general knapsack, we must choose a \textit{multiplier} $m$ and a \textit{modulus} $n$ so that $m$ and $n$ are relatively prime and $n$ is greater than the sum of all elements in the superincreasing knapsack.\\
Then the general knapsack is computed from the superincreasing knapsack by modular multiplication.\\\\
To decrypt the knapsack, use the private key to find: $C \cdot m^{-1}$ $mod$ $n$. The result is then used to solve the superincreasing knapsack and retrieve the message in binary.

\subsection{RSA}
\begin{center}
    \textit{Invented by Shamir, Rivest Adleman based on a concept by Clifford Cocks}
\end{center}

\subsubsection{How it works}
The steps for generating an RSA public and private key are the following:
\begin{enumerate}
    \item Choose two large primes $p$ and $q$.
    \item Take their product $N = pq$.
    \item Choose $e$ relatively prime to the product $(p-1)(q-1)$.
    \item Find the multiplicative inverse of $e$ $mod$ $(p-1)(q-1)$ and denote it as $d$.
\end{enumerate}
Then we get that:
\begin{itemize}
    \item $N$ = modulus
    \item $e$ = encryption exponent
    \item $d$ = decryption exponent
    \item Public key: $(N,e)$
    \item Private key: $(d)$
\end{itemize}
RSA encryption and decryption are done through \textit{modular exponentiation} therefore we have that:
\begin{center}
$C = M^e$ mod N and $M = C^d$ $mod$ $N$.
\end{center}{}
To show whether RSA works we have to demonstrate that
\begin{center}
    M = $C^d$ mod N = $M^{ed}$ $mod$ $N$
\end{center}{}
To do so we use \textbf{Euler's Theorem} which states that: if x is relatively prime to n then $x^{\phi(n)}$ = 1 mod n.\\
Recall that e and d where chosen so that 
\begin{center}
$ed$ = $1$ $mod$ $(p-1)(q-1)$
\end{center}
Furthermore we have that, $N = pq$ which implies that
\begin{center}
    $\phi(N)$ = (p-1)(q-1)
\end{center}
These two fact then imply that
\begin{center}
    $ed - 1$ = $k\phi(N)$
\end{center}
for some integer $k$, and it is not necessary to know the value of $k$. Now we can verify that RSA encryption works.
\begin{center}
    $C^d$ = $M^{ed}$ = $m^{(ed-1) + 1}$ = $M$ $\cdot M^{ed-1}$ = $M$ $\cdot M^{k\phi(N)}$ = $M$ $\cdot 1^k$ = $M$ $mod$ $n$
\end{center}
This confirms that the RSA decryption exponent, does in fact decrypt the cyphertext C.
In the real world when choosing the \textit{modulus} $N$ it is typically at least 1024 bits or 2048 bits long.

\subsubsection{A possible attack}
There is a possibility to attack RSA encryption through a \textbf{forward search attack}, in which the attacker can guess a possible message M and encrypt it with the public key, if the result matches with the ciphertext C, then the attacker has recovered the plaintext M.\\
The way to \textbf{prevent} this attack is to pad the message with random bits. Any real world RSA encryption uses padding to avoid these types of attacks.

\subsubsection{Repeated Squaring}
o make RSA more efficient and practical we use repeated squaring, In a secure implementation of RSA the modulus would be at least 1024 bits. As a result of this we would have large values for $e$ and $d$, which would be impossible to compute $M^e$ $mod$ $N$ by using the naive approach talked in sub-section 1.1. By using repeated squaring we are able to manage such large numbers at any intermediate step.\\
The way it works is that we build the exponent one bit at a time, and at each step we double the exponent, if we encounter a 1 in the binary expansion of the exponent we add a one to the exponent.

\subsubsection{Example}
Let's say we have a number $5^{20}$, first we note that the exponent in binary is equal to 10100. The exponent will then be built up, one bit at a time, beginning from the high-order bit as:
\begin{center}
    (0,1,10,101,1010,10100) = (0,1,2,5,10,20)
\end{center}{}
next we can build the exponent by using the rule mentioned above:
\begin{center}
    \begin{tabular}{l}
    $1 = 0 \cdot 2 + 1$\\
    $2 = 1 \cdot 2$\\
    $5 = 2 \cdot 2 + 1$\\
    $10 = 5 \cdot 2$\\
    $20 = 10 \cdot 2$\\
    \end{tabular}{}
\end{center}{}
Now to compute $5^{20}$, repeated squaring proceeds as follows:
\begin{center}
\begin{tabular}{l}
    $5^1 = (5^0)^2 \cdot 5^1$ = 5 mod 35\\
    $5^2 = (5^1)^2$ = 25 mod 35\\
    $5^5 = (5^2)^2 \cdot 5^1$ = 10 mod 35\\
    $5^{10} = (5^5)^2$ = 30 mod 35\\
    $5^{20} = (5^{10})^2$ = 25 mod 35\\
    \end{tabular}{}
\end{center}{}
We have a modular reduction that occurs in each step. Although we have a lot of steps to compute the numbers that we have to deal with will never be greater than the cube of the modulus.

\subsubsection{Totient Function}
The \textit{Totient function} denoted as $\phi(n)$ is the number of positive integers that are less than n and that are relatively prime to n.\\
For any prime numbers it is easy to see that $\phi(p) = p-1$ furthermore it is easy to see that if p and q are prime then we have that $\phi(pq) = (p-1)(q-1)$

\subsection{Diffie-Hellman}
\begin{center}
   \textit{Invented by Malcolm Williamson of GCHQ, reinvented by Whitfield Diffie and Martin Hellman}
\end{center}
The Diffie-Hellman algorithm is not for encrypting or signing, but it is used to allow users to establish a shared symmetric key.\\
The security of DH lies on the computational difficulty of the \textit{discrete log} problem. The mathematical setup for DH is relatively simple. Let $p$ be a prime and let $g$ be a \textit{generator} which means that for any $x$ $\in \{1,2..p-1\}$ there exists an exponent $n$ such that $x$ = $g^n$ $mod$ $p$. The prime $p$ and the generator $g$ are public.

\subsubsection{key exchange}
\begin{itemize}
\item A randomly selects a secret exponent "$a$"
\item B randomly selects a secret exponent "$b$"
\item A computes $g^a$ $mod$ $p$ and sends the result to B
\item B computes $g^b$ $mod$ $p$ and sends the result to A
\item Then A computes $(g^b)^a$ $mod$ $p$ = $g^{ab}$ $mod$ $p$
\item Then B computes $(g^a)^b$ $mod$ $p$ = $g^{ab}$ $mod$ $p$
\end{itemize}{}
In the end both A and B managed to establish a \textit{shared secret} which is $g^{ab}$ $mod$ $p$ (typically used as symmetric key)

\subsubsection{A possible attack}
After A and B established a \textit{shared secret} the only way to break it is to solve a discrete logarithmic problem. Another way to break the DH algorithm is through a MiM attack or better known as \textit{Man in the Middle} attack. It is a serious attack because the attacker can establish a shared secret without A or B knowing that the attacker knows the shared secret too. Therefore any messages that are exchanged between A and B are known to the attacker.

\subsubsection{A possible solution to a possible attack}
There are different ways to stop a MiM attack, including the following:
\begin{itemize}
    \item Encrypt the DH exchange with a shared symmetric key
    \item Encrypt the DH exchange with public keys
    \item Sign the DH values with private keys
\end{itemize}

\subsection{Elliptic Curve Cryptography}
The advantage of using Elliptic Curve Cryptography (ECC) is that fewer bits are needed compared to other cryptographies to achieve the same level of security. However ECC requires more complex operations and therefore each mathematical operation is somewhat more expensive.\\
Even thought this system requires complex and costly operations it is mostly used in public keys encryption and is nowadays used in resource-constrained environments such as hand-held devices.\\
An elliptic curve E is the graph of a function described as follows:
\begin{center}
    E: $y^2 = x^3 + ax + b$
\end{center}{}

\subsubsection{The math of ECC}
In ECC the sum between two points P1 and P2 is used to calculate a third point in the curve. The way it works is that a line is drawn between the points P1 and P2 and usually this line intersects with another point in the curve, is this happens this point is reflected on the x axis and a point P3 is found.
\begin{center}
    P3 = P1 + P2
\end{center}{}
For the cryptography in ECC we have to use the \textit{"modulo p"} to ensure that we deal with a discrete set of points. Therefore in the generic ECC equation we would get:
\begin{center}
    E: $y^2 = x^3 + ax + b$ $mod$ $p$
\end{center}{}
\subsubsection{Finding the points}
To find the points in the Elliptic curve we substitute for $x$ and finding all values of $y$. To do this, since we are working with the modulo $p$, we only need to consider points that are less than $p$ therefore we would have $x$ = $\{0,1,..,p-1\}$.\\
We then use the algorithm for adding two points on an elliptic curve which is found in Table 4.1 of the book (Information Security, Principles and Practice by Mark Stamp).

\subsubsection{ECC and Diffie-Hellman}
The Diffie-Hellman key exchange can be used with ECC to safely share a key between two people.\\
The public information will consist of a \textit{curve} and a \textit{point on the curve}.

\subsubsection{What? is this how it works?}
The way the key exchange works between two people A and B is the following:
\begin{enumerate}
    \item A selects a multiplier and multiplies the shared public point and sends the result to B.
    \item B selects a multiplier and multiples the shared public point and sends the result to A.
    \item Then A will use the multiplier with the point received by B and find the corresponding shared secret.
    \item B will do the same and finally A and B will have managed to establish a shared secret which is suitable to use as symmetric key.
\end{enumerate}{}

\subsubsection{Can it be broken?}
Yes the ECC version of the Diffie-Hellman key exchange is just as susceptible to a MiM attack as any other DH key exchange.

\newpage
\section{Hash Functions++}
A \textit{Cryptographic hash function} $h(x)$ must provide all of the following
\begin{itemize}
    \item \textbf{Compression}: For any size input $x$, the output length of $y = h(x)$ is small.
    \item \textbf{Efficiency}: It must be easy to compute $h(x)$ for any given input.
    \item \textbf{One-Way}: There is no feasible way to invert the hash.
    \item \textbf{Weak collision resistance}: It is not feasible to modify a message without changing it's hash value.
    \item \textbf{Strong collision resistance}: We cannot find any two inputs that hash to the same output.
\end{itemize}
Hash functions are extremely useful in security, one particular important use arises in the computation of digital signatures. However the security of the signature depends on the security of both the public key system and the hash function, if either is weak, the signature scheme can be broken.

\subsection{A birthday problem}
The birthday problem is used to show that a secure hash that generates an $N$-bit output can be broken with a brute force work factor of about $2^{N/2}$. In contrast, a secure symmetric key cipher with a key of length $N$ can be broken with a work factor of $2^{N-1}$. Consequently the output of an hash function must be about twice the number of bits as a symmetric cipher key for an equivalent level of security assuming that both are security.

\subsection{Cyclic Redundancy Check / CRC}
Intended for network applications: used for detecting transmission errors.\\
Computation: At the end add $(n-1)$ 0 bits and shift a divisor of $n$ bits over the input stream. Once the first bit is 1, xor the leftmost $n$ bits of the input stream by the divisor. The remainder ($n-1$ bits) is the CRC checksum.

\subsection{Tiger Hash}
\begin{itemize}
    \item \textbf{MD5}: Message Digest provides hash of 128-bit
    \item \textbf{SHA}: Secure Hash Algorithm generates 160-bit output
    \item A hash function is \textbf{secure} if no collisions have been found
\end{itemize}
Tiger hash was designed to be "\textit{fast and strong}" and for optimal performance on 64-bit processors, and it can serve as replacement for MD5 and SHA-1. Its output is of 192 bits.\\\\
Tiger hash employs four S-boxes, each of which maps 8 bits to 64 bits. It uses a "key schedule" algorithm  which since there is no key, is applied to the input block.\\
Input $X$ is padded to a multiple of 512 bits and written as
$$X = (X_0, X_1,...,X_{n-1})$$
Where each $X_i$ is 512 bits. The tiger algorithm employs one \textit{outer round} for each $X_i$. Each of $a$, $b$, $c$ is 64 bits and the initial values of ($a$, $b$, $c$) for the first round are, in hex:
\begin{center}
    $a$ = 0x0123456789ABCDEF\\
    $b$ = 0xFEDCBA9876543210\\
    $c$ = 0xF096A5B4C3B2E187\\
\end{center}
The final ($a$, $b$ ,$c$) output from one round is the initial triple for the subsequent round and the final ($a$, $b$, $c$) from the final round is the 192-bit hash value. Each function $F_m$ consists of eight \textit{inner rounds}. We let $W$ denote the 512 bit input to the inner rounds, where
\begin{center}
    $W$ = ($w_0, w_1,...,w_7$)
\end{center}
with each $w_i$ being 64 bits.\\
The input values for the $f_{m,i}$ is labeled ($a$, $b$, $c$). Each $f_{m,i}$ depends on $a$, $b$, $c$, $w_i$, and $m$, where $w_i$ is the $i$th 64-bit sub-block of the 512-bit input $W$. The subscript $m$ of $f_{m,i}$ is a multiplier. We write $c$ as
$$c = (c_0,c_1,...,c_7)$$
\begin{figure}[H]
    \centering
    \includegraphics[width=6cm]{Tigerouterround.png}
    \caption{Tiger Outer Round}
\end{figure}
where each $c_i$ is a single byte. Then $f_{m,i}$ is given by
\begin{center}
    $c = c \oplus w_i$\\
    $a = a - (S_0[c_0] \oplus S_1[c_2] \oplus S_2[c_4] \oplus S_3[c_6]$\\
    $b = b + (S_3[c_1] \oplus S_2[c_3] \oplus S_1[c_5] \oplus S_0[c_7]$\\
    $b = b \cdot m$
\end{center}
where each $S_i$ is an S-box mapping 8 bits to 64 bits. The Tiger hash consists of 24 rounds, which can be viewed as\textit{ three outer rounds}, each of which has \textit{eight inner rounds}. All intermediate hash values are 192 bits.
\begin{figure}[H]
    \centering
    \includegraphics[width=6cm]{Tigerinnerround.png}
    \caption{Tiger Inner Round}
\end{figure}
The purpose of the final multiplication step of $f_{m,i}$ is to ensure that each input to an S-box in one round is mixed into many S-boxes in the next round. Together the S-boxes, key schedule, and multiply ensure a strong avalanche effect.
\newpage
\subsubsection{Tiger S-boxes main characteristics}
\begin{itemize}
    \item 4 S-boxes, each having 256 values.
    \item Sizeof[i][j] == 8, so the values consist of 64 bits.
    \item They realize the non-linearity of the hashing function.
    \item They map 8 bit to 64 bits.
\end{itemize}{}

\subsubsection{Tiger S-boxes design considerations}
The S-boxes may be generated or ready for use.
\begin{itemize}
    \item All elements of all S-boxes are different.
    \item Any two elements have at most 3 equal bytes.
    \item Each column of 256 bytes permutes all 256 possible byte values.
    \item All columns of all S-boxes are as different as possible.
\end{itemize}{}

\subsection{HMAC}
To compute a \textit{hashed} MAC, or HMAC, we directly mix the key into M when computing the hash.\\
Let B be the block length of hash, in bytes. For all popular hashes B = 64. Next, define
\begin{center}
    $ipad$ = 0x36 repeated B times\\
    $opad$ = 0x5C repeated B times
\end{center}    
Then the HMAC of $M$ is defined to be
\begin{center}
    HMAC($M$, $K$) = $H(K \oplus opad, H(K \oplus ipad, M))$
\end{center}
This approach thoroughly mixes the key into the resulting hash. An HMAC can be used to protect message integrity, just like a MAC or a digital signature.
\newpage
\subsection{Information hiding}
\subsubsection{Steganography}
Involves hiding information in media such as image files, audio data or even software. An example is hiding information in low order bits of an html-file's color attribute.

\subsubsection{Watermarks}
Used to insert an "invisible" identifier in the data.\\
They can be categorized in:
\begin{itemize}
    \item \textit{Invisible}: Watermarks that are not supposed to be perceptible in the media.
    \item \textit{Visible}: Watermarks that are meant to be observed, such as a stamp of TOP SECRET on a document.
    \item \textit{Robust}: Watermarks that are designed to remain readable even if they are attacked.
    \item \textit{Fragile}: Watermarks that are supposed to be destroyed or damaged if any tampering occurs.
\end{itemize}
Invisible watermarking scheme could be used to hide information in a photograph, in such a way that if the photo were damaged it would be possible to reconstruct the entire image from a small surviving piece of the original.\\
It is also possible to insert a robust invisible mark in digital music to detect piracy. So when the pirated music appears on the Internet, it is possible to trace it back to its source.\\\\
Watermarking schemes are weak to \textit{collusion attacks}. Meaning that the original object and the watermarked object can be compered to determine the bits that carry the information, and it is also possible to learn about how the scheme works.

\newpage
\section{Access Control}
A \textbf{policy} is written according to a \textbf{model} using a \textbf{language}.
Types of Access Control:
\begin{itemize}
    \item \textbf{Discretionary Access Control} (DAC): Owners can "pass" permissions, e.g. (UNIX File system).
    \item \textbf{Mandatory Access Control} (MAC): Central authority imposes rules, e.g. (Military systems).
    \item \textbf{Role-Based Access Control} (RBAC): Users are assigned roles and roles are assigned specific permissions.
    \item \textbf{Attribute-Based Access Control} (ABAC): Rules are specified by using attributes. Attributes can describe users, resources, actions and the environment/s in which the action happens.
\end{itemize}

\subsection{Security Principles}
\begin{enumerate}
    \item Least Privilege: Allow only what is needed.
    \item Fail-safe defaults: Default permissions is "deny".
    \item Economy of Mechanism: As simple as possible.
    \item Complete Mediation: Every access should be checked.
    \item Open Design: Secrecy (of design/implementation) should not be the source of security.
    \item Separation of Privilege/Duty: More than one condition.
    \item Least Common Mechanism: Access mechanisms should not be shared.
    \item Least Astonishment: Understandable by the users.
\end{enumerate}

\subsection{OAUTH2}
Modern standard for securing access to APIs. There are four roles involved:
\begin{itemize}
    \item Client: Needs to register with Auth server.
    \item Resource Owner: Grants authorizations.
    \item Authorization Server: Provides access tokens.
    \item Resource Server: Sends the protected resource.
\end{itemize}

\subsection{Macaroons}
Flexible authorization tokens with the following features:
\begin{itemize}
    \item \textbf{Delegation} with attenuation and third-party restrictions.
    \item \textbf{Attenuation} on how, when and where the tokens can be exercised.
    \item \textbf{Proof-carrying:} The restrictions are constructed using chained HMAC.
    \item \textbf{Third-party restrictions:} Restrictions can be enforced by third parties.
\end{itemize}

\subsection{Authentication}
Authentication: Are you who you say you are?\\
Authorization: Are you allowed to do that?
\subsubsection{Authentication methods}
A human can be authenticated into a machine based on the following "somethings".
\begin{itemize}
    \item Something you know: such as a password.
    \item Something you have: such as an ATM card or a smartcard.
    \item Something you are: category is synonymous with biometrics.
\end{itemize}{}

\subsubsection{Passwords}
An ideal password is something that you know, that a computer can verify that you know, and something that nobody else can guess. The main problem with passwords is the non-randomness of password selection.\\
To protect passwords in databases from being found out by an attacker, passwords are appended with a \textit{salt} before hashing. A \textit{salt} is a non-secret value that causes identical passwords to hash to different values. By using this method, the work to guess a password with N users increases by a factor of N.

\subsubsection{Two-Factor Authentication}
Authentication methods that require two out of three "somethings" is know as \textit{two-factor authentication}.

\subsection{Authorization}
Authorization is a security mechanism used to determine user/client privileges or access levels related to system resources, including computer programs, files, services, data and application features. Authorization is normally preceded by authentication for user identity verification. System administrators (SA) are typically assigned permission levels covering all system and user resources.\\
During authorization, a system verifies an authenticated user's access rules and either grants or refuses resource access.

\subsubsection{Access Control Matrix}
Two important constructs in authorization are \textit{access control lists}, or ACLs, and \textit{capabilities}, or C-lists. These are derived from Lampson's \textit{access control matrix}, which has a row for every \textit{subject} (user of a system) and a column for every \textit{object} (system resource).\\\\
To increase performance for authorization operations, the access control matrix can be partitioned into more manageable pieces. So either split the matrix into columns and store each column with its corresponding object, or store the access control matrix by row, where each row is stored with its corresponding subject.
These two are know as Access Control Lists, or ACLs.\\
For \textit{Capabilities}, the association between users and files in built into the systems, whereas for ACLs, a separate method for associating users to files is required.\\
ACLs are preferred when users manage their own files and when protection is data oriented. With capabilities it's easy to delegate and it's easier to add or delete users. Due to this ability to delegate, it's easy to avoid the confused deputy.

\subsubsection{Multilevel Security Models}
Let O be an object and S a subject. the O has a \textit{classification} and S has a \textit{clearance}. The security \textit{level} of O is denoted L(O), and the security level of S is similarly denoted L(S).\\
Multilevel security is needed when subjects and objects at different levels use the same system resources.

\subsubsection{Bell-LaPadula}
Purpose is to capture the minimal requirements, with respect to confidentiality, that any MLS system must satisfy.
\begin{itemize}
    \item \textbf{Simple Security Condition}: Subject S can read object O if and only if L(O) $\leq$ L(S).
    \item \textbf{*-Property} (Star Property): Subject S can write object O if and only if L(S) $\leq$ L(O).
\end{itemize}
There is also a tranquility property which was added later on to fortify BLP
\begin{itemize}
    \item\textbf{Strong tranquility property}: Security labels can never change.
    \item \textbf{Weak tranquility property}: Security label can change, provided such a change does not violate an "established security policy."
\end{itemize}

\subsubsection{Biba's Model}
Let I(O) denote the integrity of object O and I(S) integrity of object S. Then Biba's model is defined by:
\begin{itemize}
    \item \textbf{Write Access Rule}: Subject S can write object O if an only if I(O) $\leq$ I(S).
    \item \textbf{Biba's Model}: A subject S can read the object O if and only if I(S) $\leq$ I(O).
\end{itemize}
It is a restrictive model, since it prevents objects S from ever viewing an object at a lower integrity level. It is also possible to replace Biba's model with the following:
\begin{center}
    \textbf{Low Water Mark Policy:} If subject S reads object O, then I(S) = min(I(S), I(O)).
\end{center}
Under this principle, subject S can read anything under the condition that the integrity of subject S is downgraded after accessing an object at a lower level.\\
The fundamental difference between the two is that BLP is for confidentiality, which implies a high water mark principle, while Biba is for integrity, which implies a low water mark principle.
\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{Diff_Biba_BLP.png}
    \caption{BLP versus Biba}
\end{figure}

\newpage
\section{Protocols}
In networking, protocols are the rules followed in the networked communication systems, examples of formal networking protocols include HTTP, FTP, TCP, UDP and many more.

\subsection{Authentication Protocols}
\begin{itemize}
    \item \textbf{Mutual authentication:} The two parties must prove their identities to each other.
    \item \textbf{Session key:} Symmetric key used to protect confidentiality and/or integrity of the current session, provided the authentication succeeds.
\end{itemize}
To prevent replay attacks during authentication, the server can incorporate a \textit{nonce} in the challenge. The challenge will be used to compute the appropriate response, and therefore the server is able to distinguish the current response from a replay of a previous response.

\subsubsection{Authentication Using Symmetric Keys}
To authenticate using symmetric keys we encrypt the nonce with the shared symmetric key, this ensures that  replay attacks are prevented. We also have to ensure strong mutual authentication, therefore we encrypt the user's identity together with the nonce.\\
What you want to avoid in authentication protocols is have the two sides do exactly the same thing, since this might open the door to an attack.

\subsubsection{Authentication Using Public Keys}
With public key cryptography, anybody can do public key operations, while only the user can use the private key. In public key cryptography you should not use the same key pair for signing as you use for encryption. This is because an attacker can pose as the server and without the user knowing send back the plaintext.

\subsubsection{Session Keys}
Sessions keys are used to encrypt data within each connection. This is because we want to limit the amount of data encrypted with any one particular key, and it would also limit damage in the case that one session key is compromised. It provides both \textit{confidentiality} or \textit{integrity protection} (or both) to the messages.

\subsubsection{Perfect Forward Secrecy}
The most elegant approach to achieve PFS is to use an \textit{ephemeral Diffie-Hellman} key exchange (check section 4.4). To prevent the MiM attack, the two entities must use their shared symmetric key to encrypt the Diffie-Hellman exchange. When the shared session key has been computed $K_s = g^{ab}$ $mod$ $p$, both users must forget their secret exponents $a$ and $b$.\\
The feature of the PFS protocol is that once the users have forgotten their respective secret exponents, they are not able to reconstruct the session key $K_s$.

\subsubsection{Timestamps}
A \textit{timestamp} T is a time value, which can be used instead of a \textit{nonce} to ensure freshness of the message. Since we can't rely on the clocks to be perfectly synchronized, we allow for some \textit{clock skew}, to allow any timestamps that are close to the current time. This will open a window of opportunity for a replay attack

\subsection{Authentication and TCP}
In the authentication using TCP the first message will be a synchronization request, or SYN, wehereas the second message, which acknowledges the synchronization request, is a SYN-ACK, the third message which can also contain data, acknowledges the previous message and is knows as an ACK.\\
\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{TCP_3handshake.png}
    \caption{TCP 3-Way Handshake}
\end{figure}
Since TCP connection is weak to possibles attacks, to ensure authentication, the TCP should employ a secure authentication protocol after the three-way handshake has completed.

\subsection{Zero Knowledge Proofs}
In \textit{zero knowledge proof}, or ZKP, the user wants to prove to the server that he knows a secret without revealing any information about the secret. The server must then be able to verify that the user knows the secret, without having any information about the secret. A potential advantage of using this method is that it allows for authentication with anonymity.

\newpage
\section{Real-World security protocols}
\subsection{SSH}
The Secure Shell creates a secure tunnel which can be used to secure otherwise insecure commands. An SSH session provides confidentiality and integrity protection, thereby eliminating an attacker's ability to obtain passwords and other confidential information that would otherwise be sent unprotected.

\subsection{SSL}
The socket layer lives between the application layer and the transport layer in the Internet protocol stack. SSL most often deals with Web browsing, in which case the application layer protocol is HTTP and the transport layer protocol is TCP.\\
The way the protocol works is that person A sends a request to the server to safely perform transactions, the server responds with the certificate which is then checked by person A. Person A will encrypt a symmetric key with the public key of the server and send the key to the server. This key will then be used to encrypt and integrity protect subsequent communications.

\subsubsection{Man in the middle in SSL}
In the case that the browser checks the signature on the certificate, and the browser detects that there is a problem with the certificate it will avoid the user from accessing the website, however if the user decides to continue into the website and ignore the warning, the user will have opened the door to a MiM attack. It's important to realize that this problem is due to the user's fault and not due to a flaw on the SSL protocol.

\subsection{Kerberos}
Kerberos is a popular authentication tool that uses symmetric key cryptography and timestamps. It uses a \textit{Trusted Third Party} (TTP) which shares the keys to the users. Therefore the Kerberos TTP is known as the \textbf{key distribution centre}, or KDC.\\
The master key $K_{KDC}$ is used to allow the KDC to remain stateless thus avoiding DoS attacks.\\
The KDC issues various "tickets" which contain information and key required to access the network's resources. It issues an important ticket known as the \textbf{Ticket-granting ticket}, or TGT, which is used to obtain ordinary tickets.\\
TGT = \{session key, UserID, expiration time\}\\
\textbf{Kerberized Login:}
\begin{itemize}
    \item The key $K$ is derived as $K = h(User's password)$
    \item The KDC creates session key $S$
    \item User's computer uses $K$ to obtain $S$ and the TGT; then user's computer forgets $K$
    \item TGT = E("User",$S$, $K_{KDC}$)
\end{itemize}{}
The timestamp is used to allow authentication in time and avoid replay attacks.
\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{KerberosLogin.png}
    \caption{Kerberized Login}
\end{figure}
One advantage of Kerberized login is that the entire security process is transparent to the user. The disadvantage is that is relies on the security of the KDC.

\subsubsection{Kerberos Ticket}
Once the user's computer receives its TGT, it can use the TGT to request access to network resources. To avoid replay attacks the \textit{authenticator} is used which is an encrypted timestamp. After the KDC receives and verifies the authenticator, it responds with a "ticket to server", which can then be used to communicate securely with the server.\\
Since timestamps are used for replay prevention, Kerberos minimizes the number of messages that must be sent. The main drawback is that time becomes a security-critical parameter.

\subsubsection{Kerberos Security}
If the key $K_{KDC}$ is compromised, the entire security of the system is broken. A good security feature is that the user remains anonymous in the request, so the KDC does not need to know who is making the request, before it can decrypt the TGT, since all TGTs are encrypted with $K_{KDC}$.\\
To prevent replay attacks Kerberos relies on the timestamps that appear in the authenticator. However a replay attack is still viable within the clock skew. To prevent this attacks the KDC would need to remember all timestamps that are received within the clock skew interval. However most Kerberos implementations don't do this.

\newpage
\section{Privacy}
\textit{“\textbf{Privacy forms the basis of our freedom. You have to have moments of reserve, reflection, intimacy, and solitude}"}

\subsection{K-anonymity}
Given a dataset with private info about individuals, k-anonymity requires that each individual cannot be distinguished from k-1 individuals of the same dataset.\\
\textbf{Methods to apply k-anonymity}
\begin{itemize}
    \item Suppression: Hide individual attributes.
    \item Generalization: Generalize individual attributes to broader category.
\end{itemize}{}
\textbf{Possible attacks on K-anonymity}
\begin{itemize}
    \item Homogeneity: Attacker knows some information and can guess the remaining information.
    \item Background knowledge: Attacker knows that an individual has a specific trait.
\end{itemize}{}

\subsection{L-diversity}
Generate diversity in a given quasi-identifier groups.
\begin{itemize}
    \item Distinct L-diversity: There are at least l distinct values in each equivalence class.
    \item Entropy L-diversity: The entropy of the distribution of sensitive values is at least log(l)
\end{itemize}

\begin{center}
    Entropy(E)=-$\sum$ p(E,s) log(p(E,s))
\end{center}
E = Equivalence class\\
s = Sensitive attribute value from domain S\\
p(E,s) = Fraction of records in E with value s\\
We want Entropy(E) $\leq$ log(l)\\\\
\textbf{Recursive (c,l)-diversity:} Ensures that the most common value does not appear too often while less common values are ensured to not appear too infrequently.

\subsection{T-closeness}
Distribution of sensitive attribute in each equivalence group should be 't' close to the original database.

\subsection{Differential Privacy}
\begin{center}
    \textit{"The risk associated with privacy violation of an individual should not substantially increase as a result of participating in a statistical database"}
\end{center}
There exists an algorithm K such that for all pairs of very similar data sets D and D' it will behave approximately the same on both data sets: if K(D) = X and K(D') = Y then X and Y should be indistinguishable.\\
K is really about the distribution of values in its range K(D) for the data sets it is applied.\\
Add controlled noise with general Laplace($\mu$,b), with f:
\begin{center}
    f(x$|\mu$,b) = $\frac{1}{2b} e^{-\frac{|x-\mu|}{b}}$
\end{center}
where:
\begin{itemize}
    \item b = amount of noise
    \item $\mu$ = f's sensitivity: max $|| Q_D - Q_{D'}||$
    (maximum difference in the values that the query Q may take on a pair of databases that differ in only one row)
\end{itemize}

\subsection{Location Privacy}
The concept of location privacy can be defined as the right of individuals to decide how, when, and for which purposes their location information could be released to other parties. There is a trade-off between benefit from service and protection of location info from adversary.\\
To ensure location privacy different methods exists: 
\begin{itemize}
    \item \textit{Location obfuscation} can be used in which the user's location is hidden within a region. This can be achieved by using several obfuscation operators:
\begin{itemize}
    \item \textbf{Enlarge:} According to some metric, increase radius.
    \item \textbf{Reduce:} According to some metric, reduce the radius.
    \item \textbf{Shift:} Change the exact location info.
\end{itemize}
\item \textit{Spatio-temporal:} instead of (or in addition to) pure location obfuscation, a (time) delay can be introduced to location information.
\item \textit{Data-dependent obfuscation:} Calculate region by considering k-l nearest subject locations, generate a region that contains k subjects.
\end{itemize} 

\newpage
\section{PGP, Pretty Good Privacy / GPG, Gnu's Privacy Guard}
\begin{center}
    \textit{Published by Phil Zimmermann}
\end{center}

The PGP/GPG public key infrastructure (PKI) is as follows:
\begin{itemize}
    \item Publicly (widely) known public key.
    \item Privately kept private (or secret) key.
    \item Passphrase protects access to the private key.
    \item Well-defined public key infrastructure is available.
    \item Software is free.
    \item No known practically feasible way to subvert.
\end{itemize}
The features of PGP/GPG are:
\begin{itemize}
    \item \textbf{Confidentiality}
    \begin{itemize}
        \item Encrypt your own sensitive data.
        \item Only the intended recipient can read the information.
    \end{itemize}
    \item \textbf{Integrity}
    \begin{itemize}
        \item Digital signatures are invalid when the document is modified.
    \end{itemize}
    \item \textbf{Non-repudiation}
    \begin{itemize}
        \item Verify the authenticity of the sender.
    \end{itemize}
    \item \textbf{Web of Trust}
    \begin{itemize}
        \item The signer/sender of the information is known.
    \end{itemize}
\end{itemize}

If the secret key is lost, there is no way of retrieving your encrypted information, this is because there would be no way of decrypting your information.

\end{document}
